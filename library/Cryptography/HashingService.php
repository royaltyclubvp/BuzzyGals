<?php
/**
 * Provides the ability to hash with salt and verify plaintext 
 *
 * @package     Cryptography
 * @subpackage  Services
 * @version     1
 * @author      Ozan Turgut <ozanturgut@gmail.com>
 */
class Cryptography_HashingService {
	const DEFAULT_HASH_ALGORITHM = 'sha256';
	const DEFAULT_MIN_SALT_SIZE = 4;
	const DEFAULT_MAX_SALT_SIZE = 16;

	private $hashAlgorithm = NULL;
	private $hashLength = NULL;
	private $minSaltSize = 0;
	private $maxSaltSize = 0;

	function __construct($hashAlgorithm = NULL, $minSaltSize = NULL, $maxSaltSize = NULL){
		if(!is_null($hashAlgorithm)) $this->setHashAlgorithm($hashAlgorithm);
		else $this->setHashAlgorithm(Cryptography_HashingService::DEFAULT_HASH_ALGORITHM);

		if(!is_null($minSaltSize)) $this->minSaltSize = $minSaltSize;
		else $this->minSaltSize = Cryptography_HashingService::DEFAULT_MIN_SALT_SIZE;

		if(!is_null($maxSaltSize)) $this->maxSaltSize = $maxSaltSize;
		else $this->maxSaltSize = Cryptography_HashingService::DEFAULT_MAX_SALT_SIZE;
	}

	// Returns the upper bound on the number of characters for the hashed values this service will produce	
	public function getMaxHashSize(){
		return $this->maxSaltSize + $this->hashLength;
	}

	// Sets an algorithm to be used by hash_hmac
	public function setHashAlgorithm($hashAlgorithm){
		if(!in_array($hashAlgorithm, hash_algos(), TRUE)) throw new Exception ("The passed algorithm is not found within hash_algos()");

		$this->hashAlgorithm = $hashAlgorithm;
		$this->hashLength = strlen(hash_hmac($this->hashAlgorithm, "", ""));
	}

	public function setSaltSizeLimits($minSaltSize, $maxSaltSize = NULL){
		if(is_null($maxSaltSize)) $maxSaltSize = $minSaltSize;

		if($minSaltSize > $maxSaltSize || $maxSaltSize < 1) throw new Exception("Salt size must be greater than one.");

		$this->minSaltSize = $minSaltSize;
		$this->maxSaltSize = $maxSaltSize;

		return true;
	}

	// Generates a sequence of bytes between min and max salt size
	public function generateSalt(){
		$saltSize = mt_rand($this->minSaltSize, $this->maxSaltSize);
		$saltCharArray = array();

		for($i = 0; $i < $saltSize; $i++){
			array_push($saltCharArray, chr(mt_rand(0,64)));
		}

		return implode("", $saltCharArray);
	}

	// Computes a hash value and appends the salt at the end of it
	public function Compute($clearText, $salt = NULL){
		if(is_null($salt)) $salt = $this->generateSalt();

		$hashedText = hash_hmac($this->hashAlgorithm, $clearText, $salt);

		return $hashedTextWithSalt = $hashedText . $salt;
	}

	// Verifies a hashed value which was generated by this service
	public function Verify($clearText, $hashedTextWithSalt){
		$hashedText = substr($hashedTextWithSalt, 0, $this->hashLength);
		$salt = substr($hashedTextWithSalt, $this->hashLength);	
		$expectedHashString = $this->Compute($clearText, $salt);

		return $hashedTextWithSalt === $expectedHashString;
	}
}

?>